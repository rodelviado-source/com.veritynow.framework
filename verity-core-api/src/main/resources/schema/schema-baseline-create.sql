-- =====================================================================
-- VerityNow schema (STRICT ROW-LOCK, NO LOCK AUX TABLES)
-- Goals:
--   - strict subtree locking enforced by trigger
--   - NO lock_group / path_lock auxiliary tables
--   - locking is based on PostgreSQL row locks on vn_inode
--   - mutation = moving heads (vn_node_head INSERT/UPDATE)
--   - preserve forward/backward path lookup indices
-- =====================================================================

create schema if not exists "public";
create extension if not exists ltree;

-- =========================
-- Optional global defaults (DB-level)
-- NOTE: these are "baked in" as ALTER DATABASE so they apply broadly.
-- Adjust values to taste.
-- =========================
do $$
begin
  execute format('alter database %I set lock_timeout = %L', current_database(), '0ms'); -- fail fast on locks
  execute format('alter database %I set statement_timeout = %L', current_database(), '0'); -- 0 = no limit (or set e.g. 30s)
  execute format('alter database %I set idle_in_transaction_session_timeout = %L', current_database(), '0'); -- 0 = disabled (or set e.g. 30s)
exception when others then
  -- Some environments disallow ALTER DATABASE in init scripts; ignore safely.
  null;
end;
$$;

-- =========================
-- Tables
-- =========================

create table if not exists "public"."vn_blob" (
  "hash" varchar(255) not null,
  "hash_algorithm" varchar(255) not null,
  "size" bigint not null,
  "mime_type" varchar(255),
  "name" varchar(255),
  constraint "vn_blob_pkey" primary key ("hash", "hash_algorithm")
);

create table if not exists "public"."vn_dir_entry" (
  "child_id" bigint not null,
  "created_at" timestamp(6) with time zone not null default now(),
  "id" bigint generated by default as identity not null,
  "parent_id" bigint not null,
  "name" varchar(255) not null,
  constraint "vn_dir_entry_pkey" primary key ("id"),
  constraint "uq_dir_parent_name" unique ("parent_id", "name")
);

create table if not exists "public"."vn_inode" (
  "created_at" timestamp(6) with time zone not null default now(),
  "id" bigint generated by default as identity not null,
  "scope_key" "public"."ltree",
  constraint "vn_inode_pkey" primary key ("id"),
  constraint "uq_vn_inode_scope_key" unique ("scope_key")
);

create table if not exists "public"."vn_inode_path_segment" (
  "ord" int not null,
  "created_at" timestamp(6) with time zone not null default now(),
  "dir_entry_id" bigint not null,
  "id" bigint generated by default as identity not null,
  "inode_id" bigint not null,
  constraint "vn_inode_path_segment_pkey" primary key ("id"),
  constraint "uq_inode_ord" unique ("inode_id", "ord")
);

create table if not exists "public"."vn_node_head" (
  "inode_id" bigint not null,
  "updated_at" timestamp(6) with time zone not null default now(),
  "version_id" bigint not null,
  constraint "vn_node_head_pkey" primary key ("inode_id")
);

create table if not exists "public"."vn_node_version" (
  "id" bigint generated by default as identity not null,
  "inode_id" bigint not null,
  "size" bigint not null,
  "timestamp" bigint not null default (extract(epoch from current_timestamp) * 1000)::BIGINT,

  "context_name" varchar(255),
  "correlation_id" varchar(255),

  -- NOTE: versionStore stores content hashes but does NOT FK to vn_blob
  "hash_algorithm" varchar(255),
  "hash" varchar(255),

  "mime_type" varchar(255),
  "name" varchar(255),
  "operation" varchar(255),
  "path" varchar(255),
  "principal" varchar(255),

  "transaction_id" varchar(255),
  "transaction_result" varchar(255),
  "workflow_id" varchar(255),

  constraint "vn_node_version_pkey" primary key ("id")
);

-- =========================
-- Indexes (baseline)
-- =========================

-- traversal indices
create index if not exists "ix_dir_child" on "public"."vn_dir_entry"("child_id");
create index if not exists "ix_dir_parent" on "public"."vn_dir_entry"("parent_id");

create index if not exists "ix_inode_path_inode" on "public"."vn_inode_path_segment"("inode_id");
-- helpful for reverse traversal / maintenance and some joins
create index if not exists "ix_inode_path_dir_entry" on "public"."vn_inode_path_segment"("dir_entry_id");

-- version indices
create index if not exists "ix_ver_inode_timestamp"
  on "public"."vn_node_version"("inode_id", "timestamp" desc, "id" desc);

create index if not exists "ix_ver_txn_inode"
  on "public"."vn_node_version"("transaction_id", "inode_id", "id");

create index if not exists "ix_ver_txn_result"
  on "public"."vn_node_version"("transaction_id", "transaction_result", "id");

create index if not exists "ix_ver_correlation"
  on "public"."vn_node_version"("correlation_id", "id");

create index if not exists "ix_ver_workflow"
  on "public"."vn_node_version"("workflow_id", "id");

create index if not exists "ix_ver_hash_alg"
  on "public"."vn_node_version"("hash", "hash_algorithm");

-- Optional: accelerate scope prefix lookups (ltree)
create index if not exists "ix_vn_inode_scope_key_gist"
  on "public"."vn_inode"
  using gist ("scope_key");

-- =========================
-- Foreign Keys (no blob<->version FK)
-- =========================

do $$
begin
  alter table if exists "public"."vn_dir_entry"
    add constraint "vn_dir_entry_child_id_fk"
    foreign key ("child_id") references "public"."vn_inode" ("id");
exception when duplicate_table then null;
when duplicate_object then null;
end;
$$;

do $$
begin
  alter table if exists "public"."vn_dir_entry"
    add constraint "vn_dir_entry_parent_id_fk"
    foreign key ("parent_id") references "public"."vn_inode" ("id");
exception when duplicate_table then null;
when duplicate_object then null;
end;
$$;

do $$
begin
  alter table if exists "public"."vn_inode_path_segment"
    add constraint "vn_inode_path_segment_dir_entry_id_fk"
    foreign key ("dir_entry_id") references "public"."vn_dir_entry" ("id");
exception when duplicate_table then null;
when duplicate_object then null;
end;
$$;

do $$
begin
  alter table if exists "public"."vn_inode_path_segment"
    add constraint "vn_inode_path_segment_inode_id_fk"
    foreign key ("inode_id") references "public"."vn_inode" ("id");
exception when duplicate_table then null;
when duplicate_object then null;
end;
$$;

do $$
begin
  alter table if exists "public"."vn_node_head"
    add constraint "vn_node_head_inode_id_fk"
    foreign key ("inode_id") references "public"."vn_inode" ("id");
exception when duplicate_table then null;
when duplicate_object then null;
end;
$$;

do $$
begin
  alter table if exists "public"."vn_node_head"
    add constraint "vn_node_head_version_id_fk"
    foreign key ("version_id") references "public"."vn_node_version" ("id");
exception when duplicate_table then null;
when duplicate_object then null;
end;
$$;

do $$
begin
  alter table if exists "public"."vn_node_version"
    add constraint "vn_node_version_inode_id_fk"
    foreign key ("inode_id") references "public"."vn_inode" ("id");
exception when duplicate_table then null;
when duplicate_object then null;
end;
$$;

-- =========================
-- STRICT ROW-LOCK ENFORCEMENT (trigger)
-- =========================
-- Model:
--   - acquireLock(scopes) = SELECT ... FROM vn_inode ... FOR UPDATE NOWAIT
--   - mutation = head move (INSERT/UPDATE vn_node_head)
--   - trigger enforces subtree lock by locking ALL ancestors (including self) in vn_inode FOR UPDATE NOWAIT
--
-- Behavior:
--   - if any ancestor inode row is locked by a different txn, NOWAIT fails fast -> lock conflict
--   - if caller already holds the row locks, this is a no-op (DB-level re-entrancy)
--
-- No auxiliary lock tables required.

create or replace function public.vn_lock_inode_ancestors_nowait(p_inode_id bigint)
returns void
language plpgsql
as $$
declare
  s ltree;
  lvl int;
  i int;
  anc ltree;
  dummy int;
begin
  -- Read canonical scope from vn_inode (no hashing here)
  select scope_key into s
  from public.vn_inode
  where id = p_inode_id;

  if s is null then
    -- If you allow null scopes (bootstrap/root), nothing to enforce
    return;
  end if;

  lvl := nlevel(s);

  -- Lock all ancestors including self: subpath(s, 0, i), i=1..lvl
  for i in 1..lvl loop
    anc := subpath(s, 0, i);

    -- Row-lock the inode representing this ancestor scope
    -- NOWAIT => fail fast on conflict
    select 1 into dummy
    from public.vn_inode
    where scope_key = anc
    for update nowait;

    -- If the row isn't found, we just continue.
    -- (If you want strict structural enforcement, raise exception here.)
  end loop;
end;
$$;

create or replace function public.vn_trg_node_head_strict_lock()
returns trigger
language plpgsql
as $$
begin
  perform public.vn_lock_inode_ancestors_nowait(new.inode_id);
  return new;
end;
$$;

drop trigger if exists tr_vn_node_head_strict_lock on public.vn_node_head;

create trigger tr_vn_node_head_strict_lock
before insert or update on public.vn_node_head
for each row
execute function public.vn_trg_node_head_strict_lock();
