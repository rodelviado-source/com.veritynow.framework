-- =====================================================================
-- VerityNow schema (patched)
-- Goals:
--   - locking correctness + performance (ltree overlap queries)
--   - traversal and txn query optimization
--   - NO integrity constraint between vn_blob and vn_node_version
-- =====================================================================

create schema if not exists "public";
create extension if not exists ltree;

-- =========================
-- Tables
-- =========================

create table if not exists "public"."vn_blob" (
  "hash" varchar(255) not null,
  "hash_algorithm" varchar(255) not null,
  "size" bigint not null,
  "mime_type" varchar(255),
  "name" varchar(255),
  constraint "vn_blob_pkey" primary key ("hash", "hash_algorithm")
);

create table if not exists "public"."vn_dir_entry" (
  "child_id" bigint not null,
  "created_at" timestamp(6) with time zone not null default now(),
  "id" bigint generated by default as identity not null,
  "parent_id" bigint not null,
  "name" varchar(255) not null,
  constraint "vn_dir_entry_pkey" primary key ("id"),
  constraint "uq_dir_parent_name" unique ("parent_id", "name")
);

create table if not exists "public"."vn_inode" (
  "created_at" timestamp(6) with time zone not null default now(),
  "id" bigint generated by default as identity not null,
  "scope_key" "public"."ltree",
  constraint "vn_inode_pkey" primary key ("id"),
  constraint "uq_vn_inode_scope_key" unique ("scope_key")
);

create table if not exists "public"."vn_inode_path_segment" (
  "ord" int not null,
  "created_at" timestamp(6) with time zone not null default now(),
  "dir_entry_id" bigint not null,
  "id" bigint generated by default as identity not null,
  "inode_id" bigint not null,
  constraint "vn_inode_path_segment_pkey" primary key ("id"),
  constraint "uq_inode_ord" unique ("inode_id", "ord")
);

create table if not exists "public"."vn_lock_group" (
  "lock_group_id" uuid not null,
  "owner_id" text not null,
  "fence_token" bigint,
  "active" boolean not null default true,
  "acquired_at" timestamp(6) with time zone not null default now(),
  "expires_at" timestamp(6) with time zone,
  "released_at" timestamp(6) with time zone,
  constraint "vn_lock_group_pkey" primary key ("lock_group_id")
);

create table if not exists "public"."vn_node_head" (
  "fence_token" bigint,
  "inode_id" bigint not null,
  "updated_at" timestamp(6) with time zone not null,
  "version_id" bigint not null,
  constraint "vn_node_head_pkey" primary key ("inode_id")
);

create table if not exists "public"."vn_node_version" (
  "id" bigint generated by default as identity not null,
  "inode_id" bigint not null,
  "size" bigint not null,
  "timestamp" bigint not null default (extract(epoch from current_timestamp) * 1000)::BIGINT,

  "context_name" varchar(255),
  "correlation_id" varchar(255),

  -- NOTE: versionStore stores content hashes but does NOT FK to vn_blob
  "hash_algorithm" varchar(255),
  "hash" varchar(255),

  "mime_type" varchar(255),
  "name" varchar(255),
  "operation" varchar(255),
  "path" varchar(255),
  "principal" varchar(255),

  "transaction_id" varchar(255),
  "transaction_result" varchar(255),
  "workflow_id" varchar(255),

  constraint "vn_node_version_pkey" primary key ("id")
);

create table if not exists "public"."vn_path_lock" (
  "id" bigint generated by default as identity not null,
  "lock_group_id" uuid not null,
  "owner_id" text not null,
  "scope_key" "public"."ltree" not null,
  "active" boolean not null default true,
  "acquired_at" timestamp(6) with time zone not null default now(),
  "released_at" timestamp(6) with time zone,
  constraint "vn_path_lock_pkey" primary key ("id")
);

create table if not exists "public"."vn_txn_epoch" (
  "txn_id" text not null,
  "lock_group_id" uuid,
  "fence_token" bigint,
  "status" text not null,
  "updated_at" timestamp(6) with time zone not null default now(),
  constraint "vn_txn_epoch_pkey" primary key ("txn_id")
);

-- =========================
-- Indexes (baseline + patch)
-- =========================

-- traversal indices
create index if not exists "ix_dir_child" on "public"."vn_dir_entry"("child_id");
create index if not exists "ix_dir_parent" on "public"."vn_dir_entry"("parent_id");

create index if not exists "ix_inode_path_inode" on "public"."vn_inode_path_segment"("inode_id");
-- PATCH: helpful for reverse traversal / maintenance and some joins
create index if not exists "ix_inode_path_dir_entry" on "public"."vn_inode_path_segment"("dir_entry_id");

-- lock group indices
create index if not exists "ix_vn_lock_group_active_expires" on "public"."vn_lock_group"("active", "expires_at");
create index if not exists "ix_vn_lock_group_owner_active" on "public"."vn_lock_group"("owner_id", "active");

-- PATCH: partial indexes for active-only scans (faster when inactive rows accumulate)
create index if not exists "ix_vn_lock_group_active_owner_partial"
  on "public"."vn_lock_group"("owner_id")
  where "active" = true;

create index if not exists "ix_vn_lock_group_active_expires_partial"
  on "public"."vn_lock_group"("expires_at")
  where "active" = true;

-- version indices
create index if not exists "ix_ver_inode_timestamp"
  on "public"."vn_node_version"("inode_id", "timestamp" desc, "id" desc);

-- PATCH: commit/rollback + audit scan accelerators
create index if not exists "ix_ver_txn_inode"
  on "public"."vn_node_version"("transaction_id", "inode_id", "id");

create index if not exists "ix_ver_txn_result"
  on "public"."vn_node_version"("transaction_id", "transaction_result", "id");

create index if not exists "ix_ver_correlation"
  on "public"."vn_node_version"("correlation_id", "id");

create index if not exists "ix_ver_workflow"
  on "public"."vn_node_version"("workflow_id", "id");

-- optional: if you join versions to blob meta often (still no FK)
create index if not exists "ix_ver_hash_alg"
  on "public"."vn_node_version"("hash", "hash_algorithm");

-- path lock indices
create index if not exists "ix_vn_path_lock_group" on "public"."vn_path_lock"("lock_group_id");
create index if not exists "ix_vn_path_lock_owner_active" on "public"."vn_path_lock"("owner_id", "active");

-- PATCH: active-only partial btree scans
create index if not exists "ix_vn_path_lock_active_group_partial"
  on "public"."vn_path_lock"("lock_group_id")
  where "active" = true;

create index if not exists "ix_vn_path_lock_active_owner_partial"
  on "public"."vn_path_lock"("owner_id")
  where "active" = true;

-- IMPORTANT PATCH: your previous "gist" index was BTREE (default). Fix to GiST.
create index if not exists "ix_vn_path_lock_active_scope_key_gist"
  on "public"."vn_path_lock"
  using gist ("scope_key")
  where "active" = true;

-- PATCH: prevent duplicate active locks per group/scope (retry safety + correctness)
create unique index if not exists "uq_vn_path_lock_active_group_scope"
  on "public"."vn_path_lock"("lock_group_id", "scope_key")
  where "active" = true;

-- txn_epoch indices
create index if not exists "ix_vn_txn_epoch_status" on "public"."vn_txn_epoch"("status");
-- PATCH: join/lookup by lock_group_id
create index if not exists "ix_vn_txn_epoch_lock_group" on "public"."vn_txn_epoch"("lock_group_id");

-- fence token sequence
create sequence if not exists "public"."vn_fence_token_seq" as bigint;

-- =========================
-- Foreign Keys (no blob<->version FK)
-- =========================

do $$
begin
  alter table if exists "public"."vn_dir_entry"
    add constraint "vn_dir_entry_child_id_fk"
    foreign key ("child_id") references "public"."vn_inode" ("id");
exception when duplicate_table then
  -- ignore
  null;
when duplicate_object then
  null;
end;
$$;

do $$
begin
  alter table if exists "public"."vn_dir_entry"
    add constraint "vn_dir_entry_parent_id_fk"
    foreign key ("parent_id") references "public"."vn_inode" ("id");
exception when duplicate_table then
  null;
when duplicate_object then
  null;
end;
$$;

do $$
begin
  alter table if exists "public"."vn_inode_path_segment"
    add constraint "vn_inode_path_segment_dir_entry_id_fk"
    foreign key ("dir_entry_id") references "public"."vn_dir_entry" ("id");
exception when duplicate_table then
  null;
when duplicate_object then
  null;
end;
$$;

do $$
begin
  alter table if exists "public"."vn_inode_path_segment"
    add constraint "vn_inode_path_segment_inode_id_fk"
    foreign key ("inode_id") references "public"."vn_inode" ("id");
exception when duplicate_table then
  null;
when duplicate_object then
  null;
end;
$$;

do $$
begin
  alter table if exists "public"."vn_node_head"
    add constraint "vn_node_head_inode_id_fk"
    foreign key ("inode_id") references "public"."vn_inode" ("id");
exception when duplicate_table then
  null;
when duplicate_object then
  null;
end;
$$;

do $$
begin
  alter table if exists "public"."vn_node_head"
    add constraint "vn_node_head_version_id_fk"
    foreign key ("version_id") references "public"."vn_node_version" ("id");
exception when duplicate_table then
  null;
when duplicate_object then
  null;
end;
$$;

do $$
begin
  alter table if exists "public"."vn_node_version"
    add constraint "vn_node_version_inode_id_fk"
    foreign key ("inode_id") references "public"."vn_inode" ("id");
exception when duplicate_table then
  null;
when duplicate_object then
  null;
end;
$$;

do $$
begin
  alter table if exists "public"."vn_path_lock"
    add constraint "vn_path_lock_lock_group_id_fk"
    foreign key ("lock_group_id") references "public"."vn_lock_group" ("lock_group_id");
exception when duplicate_table then
  null;
when duplicate_object then
  null;
end;
$$;
